---
title: "Compound Components"
description: “Compound components can be said to be a pattern that encloses the state and the behavior of a group of components but still gives the rendering control of its variable parts back to the external user.”
repository: https://medium.com/@alecsquire/compound-components-in-react-a-simplified-approach-8ace72520fea
date: "2023-05-21"
published: true
---

Photo by <a href=”https://unsplash.com/@robbie36?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Robert Collins</a> on <a href=”https://unsplash.com/photos/four-boy-playing-ball-on-green-grass-tvc5imO5pXk?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a>
Photo by Robert Collins on Unsplash
React developers often face the challenge of managing complex states and passing props across multiple component layers. This process, known as prop drilling, can quickly become cumbersome, especially in larger applications. However, before making any drastic refactoring decisions perhaps consider…. compound components.

“Compound components can be said to be a pattern that encloses the state and the behavior of a group of components but still gives the rendering control of its variable parts back to the external user.”

So basically it’s how state behaves across a component which is enclosed by an external user being the parent of the component.

By adopting a pattern similar to certain HTML element relationships, React’s compound components enable efficient sharing of states and functionality without the mess of prop drilling.

The Beauty of Compound Components

Just like how `<li>` elements gain added functionality when nested within `<ul>` or `<ol>` tags, or how a `<button>` within a `<form>` automatically inherits submission capabilities, compound components in React allow child components to implicitly share state and functions provided by their parent component. This not only makes the code more readable and maintainable but also keeps your component architecture flat and simple.

Here’s how you can harness the power of compound components:

Step 1: Create Your Parent Component

First, we define a parent component that uses React’s Context API to share its state with children:

import React, { useState } from "react";

const ToggleContext = React.createContext();

export const Toggle = ({ children }) => {
 const [on, setOn] = useState(false);
 const toggle = () => setOn((current) => !current);

return (

{" "}

<ToggleContext.Provider value={{ on, toggle }}>
  {children}
</ToggleContext.Provider>
); }; The `Toggle` component here acts as the central hub for the shared state (`on`)
and a method to alter it (`toggle`).

Step 2: Creating Child Components

Next up are our child components that consume the provided context:

const ToggleButton = () => {
return (

{" "}

<ToggleContext.Consumer>
  {({ on, toggle }) => (
    <button onClick={toggle}>{on ? "Turn Off" : "Turn On"}</button>
  )}
</ToggleContext.Consumer>
); };

const ToggleMessage = () => {
return (

{" "}

<ToggleContext.Consumer>
  {({ on }) => (on ? <p>The system is ON</p> : <p>The system is OFF</p>)}
</ToggleContext.Consumer>
); }; The `ToggleButton` toggles our system’s status upon each click, while `ToggleMessage`
displays whether our hypothetical system is currently on or off.

Step 3: Putting It All Together

We’ll use these components together within our `Toggle` component to demonstrate seamless state sharing:

const App = () => {
return (

{" "}

<Toggle>
  <ToggleButton />
  <ToggleMessage />
</Toggle>
); }

By wrapping both `ToggleButton` and `ToggleMessage` inside the `Toggle` component, we ensure they access the same shared context without directly passing props down through each layer.

Conclusion

Whether you’re building a simple toggle feature or an extensive application with numerous interacting parts, embracing compound components could significantly streamline your development process.
